# Computational Thinking :computer:

<p> In this repository I walk through the area of ‚Äã‚Äãcomputational thinking and show you how to think computationally and learn algorithms and search and navigation methods doesn't have to be something out of this world! </p>


## Introduction

The first question we can ask ourselves when we come across the words _computational thinking_ is: what does it mean in practical terms?

This is because many people believe that thinking computationally is performing a complex task, which involves a function requiring the use of a computerized machine.

The term, despite implying such things, can be defined, according to researcher and vice president of Microsoft Research Jeannette Wing, as **the basis for the identification of problems and solutions that can be carried out by both processors and by human beings**.

To understand the basis of computational thinking, let's think about the following: what do an electronic voting machine and a person preparing a cake recipe have in common?

First, let's understand what electronic voting machines do, implemented as a means of voting for elections in Brazil since 1996. Electronic voting machines, using available technology, allow greater transparency in the election processes of countries with dimensions continents like ours and others around the world.

Despite its simplicity in use, the electronic voting machine is a device that makes use of a computer technology that is not common to people's daily lives, so much so that it only appears in our environment in a few years, a few times.

In order to assist voters in the process of understanding its use and for training in advance, the Superior Electoral Court (TSE), the government agency responsible for organizing and supervising elections, offers a voting simulator available [here](https:/ /www.tse.jus.br/eleicoes/urna-eletronica/simulacao-de-votacao).

Now, when I think of a person (the same person who participates in elections and is part of a democratic system in Brazil) who would like to practice their culinary skills and make a chocolate cake, what could they have in common with this electronic device that is the urn mentioned above?

For this, we need to establish what are the characteristics of computational thinking.



## Pillars of Computational Thinking

According to the definition of computational thinking given above, it is necessary to process a formula of thinking that expresses a solution in such a way that an agent, be it human or computer, can effectively solve it.

But for the solution to be computationally thought, there are some pillars that guide us to create strategies and help us in this task. Are they:

1. **Decompose the problem**: decomposition is nothing less than dividing the problem into smaller parts and then combining the solution of these smaller problems and reconstructing it;

2. **Recurrent pattern recognition**: identify patterns found in more than one part of the problem, as well as find patterns in other problems that are known to solve (eg, to use the electronic voting machine, you have to press a sequence of number buttons and then a specific key to confirm, blank or correct)

3. **Task abstraction and its input and output data (_inputs_ and _outputs_)**: list the tasks needed to solve the problem, the data needed for each task and the results produced by them.

4. **Explain the problem solving algorithm:** finally, produce the algorithm in "a sequence of unambiguous instructions to solve a problem in order to produce, in a finite period of time, the corresponding output for any input legitimate".

Returning to the examples of the electronic voting machine and the person preparing a cake recipe, in both cases all the pillars of computational thinking are carried out in order to perform the proposed tasks.

For the electronic voting machine to work, you first need to **decompose** the task into subtasks: type the numbers one at a time and after that, press the correct key. If the number pressed is incorrect, it can be corrected by pressing the "correct" key. If the voter wishes to vote null, there is the possibility of pressing the "null" key. It is noticed that there is a **recurring pattern** in all these tasks, which is to use keys to execute them, in a certain order. We can also **abstract** such tasks so that we list what is needed to perform them, that is, to carry out the voting process. At the end of the day, it is remarkable that we have an established **algorithm**!

Now, a person making a [chocolate cake recipe](https://www.panelinha.com.br/receita/Bolo-de-chocolate-com-ganache), in a similar way, needs to establish an algorithm to execute the proposed task, which is, in the end, to have a great cake to taste! For this, the task needs to be **decomposed** into smaller tasks, such as selecting the necessary ingredients and their quantities, utensils, etc. Also, the recipe needs to be followed in a certain **recurring pattern** for it to work, **abstracting** the subsequent actions and results after the listing is done.

Thus, the pillars of computational thinking are applied to formulate problems and solve them, whether you are a person, whether you are a computer, a cell phone, a NASA computerized device, a group of people, etc. The step-by-step process is the same! And this is where the **algorithms** come in, explained below.


## Algorithms

When we think of algorithms, we may automatically think of math, things that we learned in elementary school and that we were actually taught from an early age. But why should it be complicated?

An algorithm is nothing more than a plan, a strategy or a set of instructions that aims to solve a problem or perform a certain task in a period of time.

The formulation of an algorithm passes through the pillars of computational thinking of decomposition, recognition of recurrent patterns, abstraction.

There are several ways to write an algorithm, the most common being:

+ diagram

+ Flowchart

+ Pseudocode, or human language

+ Code, or programming language (in this case, who will interpret your algorithm will be a computational agent)

Some examples of common algorithms that we perform daily are: brushing our teeth, preparing a meal, driving a car, assembling a piece of furniture, writing a text or email, etc.

## Hands on! üôå

Now that we understand how we can exercise our computational thinking process and build algorithms, why not test our skills with some hands-on exercises?

Below I recommend some sites that can be useful in this journey of building a solid foundation of logic and programming logic, so that you become more than a good professional in the area of ‚Äã‚ÄãTechnology, but a person capable of solving problems and finding solutions. creative and focused on a rational logic for any type of problem.

+ [ProjectEuler](https://projecteuler.net/)
+ [HackerRank](https://www.hackerrank.com/)
+ [CodeWars](https://www.codewars.com/)
+ [Codility](https://www.codility.com/)

**Good studies and until the next module! Follow the project and leave a ‚≠ê to support it!**